<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>JSON Item Kompakt-Liste (Layout Fix)</title>
    <style>
        :root {
            --bg: #f6f8fa;
            --fg: #24292e;
            --border: #e1e4e8;
            --accent: #0366d6;
            --muted: #586069;
            --error-bg: #fddfdf;
            --error-fg: #d73a49;
            --success: #28a745;
            --success-dark: #218838;
            --qr-bg: #fff;
            --print-bg: #fff;
            --print-fg: #000;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font: 13px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--fg);
            padding: 15px;
        }
        h1 { text-align: center; margin-bottom: 15px; font-size: 1.4em; color: var(--accent); }

        .controls-container,
        .options-box,
        #progressContainer,
        #itemsContainer {
            background: #fff;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 15px;
            padding: 12px;
        }
        .options-box h3 { font-size: 1.1em; margin-bottom: 10px; color: var(--muted); }
        .option-group { margin-bottom: 10px; display: flex; align-items: center; }
        .option-group label {
            width: 140px; color: var(--muted); font-weight: 500;
        }
        .option-group select,
        .option-group input[type="range"],
        .option-group button {
            flex: 1; padding: 6px 10px; font-size: 0.9em;
            border: 1px solid #d1d5da; border-radius: 4px;
            margin-right: 10px;
        }
        .option-group output { width: 40px; text-align: right; font-size: 0.9em; }

        textarea {
            width: 100%; min-height: 70px;
            border: 1px solid #d1d5da; border-radius: 4px;
            padding: 8px; margin-bottom: 8px;
            font-size: 0.95em;
        }
        input[type="file"] { display: block; margin-bottom: 8px; font-size: 0.95em; }
        button {
            cursor: pointer; border-radius: 4px; border: none;
            font-size: 0.95em;
        }
        #processJsonBtn {
            background: var(--success); color: #fff; padding: 7px 12px;
            transition: background 0.2s;
        }
        #processJsonBtn:hover { background: var(--success-dark); }
        #regenerateQrButton {
            background: #007bff; color: #fff; padding: 6px 10px;
            transition: background 0.2s;
        }
        #regenerateQrButton:hover { background: #0056b3; }

        .error-message {
            display: none; color: var(--error-fg);
            background: var(--error-bg); border: 1px solid var(--error-fg);
            padding: 8px; border-radius: 4px; margin-bottom: 12px;
            font-size: 0.9em;
        }

        #progressContainer p {
            font-size: 0.95em; color: var(--muted); margin-bottom: 5px;
        }
        #progressBarOuter {
            width: 100%; background: #e0e0e0; height: 20px; border-radius: 4px;
            overflow: hidden;
        }
        #progressBarInner {
            height: 100%; background: var(--success); text-align: center;
            line-height: 20px; color: #fff; font-weight: bold; font-size: 0.85em;
            transition: width 0.2s;
        }

        #itemsContainer { padding: 5px 10px; }
        .item-entry { display: flex; justify-content: space-between; padding: 10px 0; }
        .item-text-details { flex: 1; padding-right: 15px; min-width: 0; }
        .item-name-line {
            display: flex; align-items: baseline; margin-bottom: 5px;
            flex-wrap: nowrap;
        }
        .item-detail-name {
            font-size: 1.1em; font-weight: 600; color: var(--accent);
            margin-right: 8px; flex: 1; min-width: 0; word-break: break-word;
        }
        .item-byte-info {
            font-size: 0.8em; color: #6a737d; white-space: nowrap;
        }
        .item-detail-line {
            font-size: 0.95em; margin-bottom: 3px; word-wrap: break-word;
        }
        .item-detail-line .detail-label { color: var(--muted); font-weight: 500; margin-right: 4px; }
        .item-detail-line.item-uri .data-value { word-break: break-all; }
        .item-detail-notes { margin-top: 4px; }
        .item-detail-notes .detail-label {
            color: var(--muted); font-weight: 500;
            display: block; margin-bottom: 2px; font-size: 0.95em;
        }
        .notes-content-display {
            background: var(--bg); padding: 5px; border-radius: 3px;
            max-height: 100px; overflow-y: auto; white-space: pre-wrap;
            word-wrap: break-word; font-size: 0.9em;
        }
        .qr-code-container {
            flex-shrink: 0; width: 120px; height: 120px;
            border: 1px solid var(--border); display: flex;
            align-items: center; justify-content: center;
            transition: width 0.2s, height 0.2s; overflow: hidden;
        }
        .qr-code-container img, .qr-code-container canvas {
            width: 100% !important; height: 100% !important;
            object-fit: contain; display: block !important;
        }
        .item-separator {
            height: 1px; background: var(--border); border: none;
        }
        #itemsContainer > .item-separator:last-child { display: none; }

        @media print {
            body {
                margin: 0 !important;
                padding: 8mm !important;
                font-size: 8pt !important;
                background-color: #fff !important;
                color: #000 !important;
            }
            .page-title-header, .controls-container, .options-box, .error-message,
            button, title, noscript, #progressContainer, h1 {
                display: none !important;
            }
            #itemsContainer {
                border: none !important;
                border-radius: 0 !important;
                padding: 0 !important;
                background-color: transparent !important;
            }
            .item-entry {
                padding: 6px 0 !important;
                align-items: flex-start !important;
            }
            .item-name-line {
                flex-wrap: wrap !important; /* Allow byte info to wrap below name if constrained */
            }
            .item-detail-name {
                font-size: 1.05em !important;
                color: #000 !important;
                margin-bottom: 2px !important;
            }
            .item-byte-info {
                font-size: 0.75em !important;
                color: #333 !important;
            }
            .item-detail-line { font-size: 0.95em !important; margin-bottom: 2px !important; }
            .item-detail-line .detail-label { color: #333 !important; }
            .item-detail-line .data-value { color: #000 !important; }

            .item-detail-notes .detail-label { color: #000 !important; font-size: 0.95em !important;}
            .notes-content-display {
                background-color: #f0f0f0 !important;
                color: #000 !important;
                font-size: 0.9em !important;
                max-height: none !important;
                overflow-y: visible !important;
                border: 1px solid #ccc !important;
                padding: 3px !important;
            }

            .qr-code-container {
                border: 1px solid #ccc !important;
            }
            .qr-code-container img,
            .qr-code-container canvas {
                width: 100% !important;
                height: 100% !important;
                object-fit: contain !important;
            }
            .item-separator {
                background-color: #aaa !important;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/davidshimjs-qrcodejs@0.0.2/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
</head>
<body>
<h1 class="page-title-header">JSON Item Kompakt-Liste (Layout Fix)</h1>

<div class="controls-container">
    <label for="jsonInput">JSON-Daten einfügen:</label>
    <textarea id="jsonInput" placeholder="JSON hier einfügen..."></textarea>
    <label for="fileInput">Oder JSON-Datei auswählen:</label>
    <input type="file" id="fileInput" accept=".json,.txt">
    <button id="processJsonBtn">JSON verarbeiten</button>
</div>

<div class="options-box">
    <h3>QR-Code Optionen</h3>
    <div class="option-group">
        <label for="qrSizeSelector">Größe (Anzeige):</label>
        <select id="qrSizeSelector">
            <option value="90">Klein (90px)</option>
            <option value="120" selected>Mittel (120px)</option>
            <option value="150">Groß (150px)</option>
            <option value="auto">Auto</option>
        </select>
    </div>
    <div class="option-group">
        <label for="compressionThresholdSlider">Kompression ab:</label>
        <input type="range" id="compressionThresholdSlider" min="256" max="2800" step="64" value="2800">
        <output id="compressionThresholdValue">2800</output> B
    </div>
    <div class="option-group">
        <button id="regenerateQrButton">QR-Codes aktualisieren</button>
    </div>
</div>

<div id="progressContainer" style="display:none">
    <p><span id="progressAction">Verarbeite</span>: <span id="progressText">0</span>/<span id="progressTotal">0</span></p>
    <div id="progressBarOuter"><div id="progressBarInner">0%</div></div>
</div>

<div id="errorMessage" class="error-message"></div>
<div id="itemsContainer"></div>

<script>
    const COMPRESSION_PREFIX = "z64:";
    let originalItems = [], processedItems = [];

    // Initialize UI controls
    document.addEventListener('DOMContentLoaded', () => {
        const slider = document.getElementById('compressionThresholdSlider');
        slider.oninput = () => document.getElementById('compressionThresholdValue').textContent = slider.value;
        document.getElementById('processJsonBtn').addEventListener('click', processJson);
        document.getElementById('regenerateQrButton').addEventListener('click', regenerateAllQrCodes);
    });

    async function processJson() {
        resetUI();
        const fileInput = document.getElementById('fileInput');
        const jsonInput = document.getElementById('jsonInput');
        const errorMsg = document.getElementById('errorMessage');

        let jsonDataString = "";
        if (fileInput.files.length > 0) {
            try {
                const file = fileInput.files[0];
                jsonDataString = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = () => reject('Fehler beim Lesen der Datei.');
                    reader.readAsText(file);
                });
                fileInput.value = '';
            } catch (err) {
                showError(err.message || 'Fehler beim Lesen der Datei.');
                return;
            }
        } else if (jsonInput.value.trim()) {
            jsonDataString = jsonInput.value;
        } else {
            showError('Bitte JSON-Daten einfügen oder eine Datei auswählen.');
            return;
        }

        try {
            const jsonData = JSON.parse(jsonDataString);
            await renderItems(jsonData);
        } catch (error) {
            showError('Fehler beim Parsen des JSON: ' + error.message);
        }
    }

    function showError(message) {
        const errorDiv = document.getElementById('errorMessage');
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
        document.getElementById('progressContainer').style.display = 'none';
    }

    function resetUI() {
        document.getElementById('errorMessage').textContent = '';
        document.getElementById('errorMessage').style.display = 'none';
        document.getElementById('itemsContainer').innerHTML = '';
        originalItems = [];
        processedItems = [];
    }

    function updateProgress(current, total, action = "Verarbeite") {
        const container = document.getElementById('progressContainer');
        const textEl = document.getElementById('progressText');
        const totalEl = document.getElementById('progressTotal');
        const barEl = document.getElementById('progressBarInner');
        const actionEl = document.getElementById('progressAction');

        container.style.display = 'block';
        actionEl.textContent = action;
        textEl.textContent = current;
        totalEl.textContent = total;

        const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
        barEl.style.width = percentage + '%';
        barEl.textContent = percentage + '%';
    }

    function getByteLength(str) {
        return new TextEncoder().encode(str).length;
    }

    function uint8ArrayToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    }

    function prepareQrData(itemData, threshold) {
        const originalJsonString = JSON.stringify(itemData);
        const originalJsonBytes = getByteLength(originalJsonString);
        let qrDataString = originalJsonString;
        let compressedRawBytes = null;
        let wasCompressed = false;

        if (originalJsonBytes > threshold && typeof pako !== 'undefined') {
            try {
                const compressedData = pako.deflate(originalJsonString);
                compressedRawBytes = compressedData.length;
                if (compressedRawBytes < originalJsonBytes * 0.9) {
                    qrDataString = COMPRESSION_PREFIX + uint8ArrayToBase64(compressedData);
                    wasCompressed = true;
                } else {
                    compressedRawBytes = null;
                }
            } catch (e) {
                console.error("Error during compression:", e);
                compressedRawBytes = null;
            }
        }

        return { qrDataString, originalJsonBytes, compressedRawBytes, wasCompressed };
    }

    function getQrDisplaySize(qrDataLength) {
        const sizeSetting = document.getElementById('qrSizeSelector').value;
        if (sizeSetting === 'auto') {
            if (qrDataLength < 500) return 90;
            if (qrDataLength < 1500) return 120;
            return 150;
        }
        return parseInt(sizeSetting, 10) || 120;
    }

    function generateSingleQrCode(container, dataString) {
        container.innerHTML = '';

        try {
            if (typeof QRCode === 'undefined') {
                container.textContent = '[QR Lib fehlt]';
                return;
            }

            new QRCode(container, {
                text: dataString,
                width: 512,
                height: 512,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.L
            });

            // Ensure only one child and proper styling
            if (container.children.length > 1) {
                while (container.children.length > 1) {
                    container.removeChild(container.lastChild);
                }
            }

            if (container.firstChild) {
                container.firstChild.style.width = '100%';
                container.firstChild.style.height = '100%';
            }
        } catch (e) {
            console.error("Error creating QR code:", e);
            container.textContent = "[QR Fehler]";
            container.style.fontSize = "0.8em";
            container.style.color = "red";
            container.style.textAlign = "center";
        }
    }

    function shortenUri(originalUri, maxLength = 50) {
        if (!originalUri) return originalUri;
        let uri = String(originalUri).replace(/^https?:\/\/(www\.)?/i, '');
        if (uri.length > maxLength) {
            uri = uri.substring(0, maxLength - 3) + '...';
        }
        return uri;
    }

    function createTextDetail(parent, label, value, options = {}) {
        if (!value || String(value).trim() === '') return null;

        const p = document.createElement('p');
        p.className = 'item-detail-line';
        if (options.className) p.classList.add(options.className);

        const labelSpan = document.createElement('span');
        labelSpan.className = 'detail-label';
        labelSpan.textContent = label + ':';

        const valueSpan = document.createElement('span');
        valueSpan.className = 'data-value';
        valueSpan.textContent = value;

        p.appendChild(labelSpan);
        p.appendChild(document.createTextNode(' '));
        p.appendChild(valueSpan);
        parent.appendChild(p);

        return p;
    }

    async function renderItems(jsonData) {
        const itemsContainer = document.getElementById('itemsContainer');
        const compressionThreshold = parseInt(document.getElementById('compressionThresholdSlider').value, 10);

        if (!jsonData || typeof jsonData !== 'object') {
            showError('Ungültige JSON-Struktur.');
            return;
        }

        const items = jsonData.items;
        if (!Array.isArray(items)) {
            showError('Kein gültiges "items"-Array.');
            return;
        }

        if (items.length === 0) {
            itemsContainer.textContent = 'Keine Items im JSON gefunden.';
            return;
        }

        document.getElementById('progressContainer').style.display = 'block';
        updateProgress(0, items.length);

        // Calculate global auto size if needed
        let globalAutoSize = null;
        if (document.getElementById('qrSizeSelector').value === 'auto') {
            let maxQrDataLength = 0;

            for (const item of items) {
                if (typeof item !== 'object' || item === null) continue;

                const itemForQr = JSON.parse(JSON.stringify(item));
                const loginData = itemForQr.login || {};

                if (loginData.uris && Array.isArray(loginData.uris)) {
                    loginData.uris = loginData.uris.map(uriObj =>
                        (uriObj && uriObj.uri) ? {...uriObj, uri: shortenUri(uriObj.uri)} : uriObj
                    );
                }

                const { qrDataString } = prepareQrData(itemForQr, compressionThreshold);
                maxQrDataLength = Math.max(maxQrDataLength, qrDataString.length);
            }

            if (maxQrDataLength < 500) globalAutoSize = 90;
            else if (maxQrDataLength < 1500) globalAutoSize = 120;
            else globalAutoSize = 150;
        }

        for (let i = 0; i < items.length; i++) {
            const originalItem = items[i];
            if (typeof originalItem !== 'object' || originalItem === null) {
                updateProgress(i + 1, items.length);
                await new Promise(resolve => setTimeout(resolve, 0));
                continue;
            }

            originalItems.push(originalItem);

            // Create a copy for QR code with shortened URIs
            const itemForQr = JSON.parse(JSON.stringify(originalItem));
            const loginDataForQr = itemForQr.login || {};

            if (loginDataForQr.uris && Array.isArray(loginDataForQr.uris)) {
                loginDataForQr.uris = loginDataForQr.uris.map(uriObj =>
                    (uriObj && uriObj.uri) ? {...uriObj, uri: shortenUri(uriObj.uri)} : uriObj
                );
            }

            processedItems.push(itemForQr);

            // Prepare QR data
            const { qrDataString, originalJsonBytes, compressedRawBytes, wasCompressed } =
                prepareQrData(itemForQr, compressionThreshold);

            // Create item entry
            const itemEntryDiv = document.createElement('div');
            itemEntryDiv.className = 'item-entry';
            itemEntryDiv.dataset.itemIndex = i;

            // Text details section
            const textDetailsDiv = document.createElement('div');
            textDetailsDiv.className = 'item-text-details';

            // Name line with byte info
            const nameLineDiv = document.createElement('div');
            nameLineDiv.className = 'item-name-line';

            const loginData = originalItem.login || {};
            let hasContent = false;

            if (originalItem.name) {
                const nameEl = document.createElement('h4');
                nameEl.className = 'item-detail-name';
                nameEl.textContent = originalItem.name;
                nameLineDiv.appendChild(nameEl);
                hasContent = true;
            }

            const byteInfoSpan = document.createElement('span');
            byteInfoSpan.className = 'item-byte-info';
            let byteInfoText = `(JSON: ${originalJsonBytes} B`;

            if (wasCompressed && compressedRawBytes !== null) {
                byteInfoText += `, Kompr.: ${compressedRawBytes} B`;
            }

            byteInfoText += ')';
            byteInfoSpan.textContent = byteInfoText;
            nameLineDiv.appendChild(byteInfoSpan);
            textDetailsDiv.appendChild(nameLineDiv);

            // Add login details
            if (createTextDetail(textDetailsDiv, 'User', loginData.username)) hasContent = true;
            if (createTextDetail(textDetailsDiv, 'Pass', loginData.password)) hasContent = true;
            if (createTextDetail(textDetailsDiv, 'TOTP', loginData.totp)) hasContent = true;

            // Add URI if available
            if (Array.isArray(loginData.uris) && loginData.uris.length > 0) {
                const firstUriObj = loginData.uris[0];
                if (firstUriObj && firstUriObj.uri) {
                    const shortUri = shortenUri(firstUriObj.uri);
                    if (createTextDetail(textDetailsDiv, 'URI', shortUri, {className: 'item-uri'})) {
                        hasContent = true;
                    }
                }
            }

            // Add notes if available
            if (originalItem.notes) {
                const notesContainer = document.createElement('div');
                notesContainer.className = 'item-detail-notes';

                const notesLabel = document.createElement('span');
                notesLabel.className = 'detail-label';
                notesLabel.textContent = 'Notizen:';

                const notesContent = document.createElement('div');
                notesContent.className = 'notes-content-display';
                notesContent.textContent = originalItem.notes;

                notesContainer.appendChild(notesLabel);
                notesContainer.appendChild(notesContent);
                textDetailsDiv.appendChild(notesContainer);
                hasContent = true;
            }

            itemEntryDiv.appendChild(textDetailsDiv);

            // QR code section
            const qrContainer = document.createElement('div');
            qrContainer.className = 'qr-code-container';

            const displaySize = globalAutoSize !== null ? globalAutoSize : getQrDisplaySize(qrDataString.length);
            qrContainer.style.width = displaySize + 'px';
            qrContainer.style.height = displaySize + 'px';

            generateSingleQrCode(qrContainer, qrDataString);
            itemEntryDiv.appendChild(qrContainer);

            // Add to container if it has content
            if (hasContent || originalItem.name) {
                itemsContainer.appendChild(itemEntryDiv);

                if (i < items.length - 1) {
                    const separator = document.createElement('hr');
                    separator.className = 'item-separator';
                    itemsContainer.appendChild(separator);
                }
            }

            updateProgress(i + 1, items.length);
            await new Promise(resolve => setTimeout(resolve, 0));
        }

        if (itemsContainer.childElementCount === 0 && items.length > 0) {
            itemsContainer.textContent = 'Keine anzeigbaren Textdaten in den Items gefunden.';
        }

        const progressBar = document.getElementById('progressBarInner');
        if (items.length > 0) {
            progressBar.textContent = 'Fertig!';
        } else {
            document.getElementById('progressContainer').style.display = 'none';
        }
    }

    async function regenerateAllQrCodes() {
        if (processedItems.length === 0) {
            alert("Keine Daten zum Aktualisieren der QR-Codes vorhanden.");
            return;
        }

        const progressContainer = document.getElementById('progressContainer');
        progressContainer.style.display = 'block';
        updateProgress(0, processedItems.length, "Aktualisiere QR");

        const compressionThreshold = parseInt(document.getElementById('compressionThresholdSlider').value, 10);

        // Calculate global auto size if needed
        let globalAutoSize = null;
        if (document.getElementById('qrSizeSelector').value === 'auto') {
            let maxQrDataLength = 0;

            for (const itemData of processedItems) {
                const { qrDataString } = prepareQrData(itemData, compressionThreshold);
                maxQrDataLength = Math.max(maxQrDataLength, qrDataString.length);
            }

            if (maxQrDataLength < 500) globalAutoSize = 90;
            else if (maxQrDataLength < 1500) globalAutoSize = 120;
            else globalAutoSize = 150;
        }

        const itemEntries = document.querySelectorAll('.item-entry');

        for (let i = 0; i < itemEntries.length; i++) {
            const itemEntry = itemEntries[i];
            const itemIndex = parseInt(itemEntry.dataset.itemIndex, 10);
            const itemData = processedItems[itemIndex];

            const qrContainer = itemEntry.querySelector('.qr-code-container');
            const byteInfo = itemEntry.querySelector('.item-byte-info');

            if (qrContainer && itemData) {
                const { qrDataString, originalJsonBytes, compressedRawBytes, wasCompressed } =
                    prepareQrData(itemData, compressionThreshold);

                const displaySize = globalAutoSize !== null ? globalAutoSize : getQrDisplaySize(qrDataString.length);
                qrContainer.style.width = displaySize + 'px';
                qrContainer.style.height = displaySize + 'px';

                generateSingleQrCode(qrContainer, qrDataString);

                // Update byte info
                if (byteInfo) {
                    let byteInfoText = `(JSON: ${originalJsonBytes} B`;
                    if (wasCompressed && compressedRawBytes !== null) {
                        byteInfoText += `, Kompr.: ${compressedRawBytes} B`;
                    }
                    byteInfoText += ')';
                    byteInfo.textContent = byteInfoText;
                }
            }

            updateProgress(i + 1, itemEntries.length, "Aktualisiere QR");
            await new Promise(resolve => setTimeout(resolve, 0));
        }

        document.getElementById('progressBarInner').textContent = 'QR Fertig!';
    }
</script>
</body>
</html>